# Распределение памяти для данных. Статическое распределение памяти.
Машинные команды всегда включают в себя код операции и адреса операндов.
Возникает задача распределения памяти для данных, описанных в программе.
Эта задача должна быть решена до начала генерации машинных команд.

Различают два метода распределения памяти:
1. Статическая: адреса назначаются компилятором, при загрузке программы могут быть сдвинуты на величину, зависящую от адреса загрузки, но при выполнении программы уже не меняются.
2. Динамическая: адреса назначаются в ходе выполнения программы и могут меняться.

В большинстве языков используется блочная структура программы, при которой область действия переменных, описанных в каком-то блоке, распространяются на этот блок и блоки, вложенные в него.

Пример:
```C
void main() { // block1 & m1
    int a, b;
    {
        int a1, b1; // block2 & m2
        {
            int d; // block3 & m3
        }
        // m4
        {
            int d1; // block4 & m5
        }
        // m7
    }
    {
        int e, f,; // block5 & m8
    }
    // m9
}
```

Блочную структуру можно представить в виде дерева.
```
block1(a, b) ->  block5(e, f)
 |
 \->  block2(a1, b1) -> block3(d)
       |
       \->  block(d1)
```

Допустим, память для данных распределяется с адреса как длина переменной int - 4 байта.
Тогда состояние памяти при выполнении программы меняется в зависимости от видимосоти переменных.

| память | m1 | m2  | m3  | m4  | m6 | m7 | m8 | m9 |
|:-------|:---|:----|:----|:----|:---|:---|:---|:---|
| `k+0`  | a  | a   | a   | a   | a  | a  | a  | a  |
| `k+4`  | b  | b   | b   | b   | b  | b  | b  | b  |
| `k+8`  |    | a1  | a1  | a1  | a1 |    | e  |    |
| `k+12` |    | b1  | b1  | b1  | b1 |    | f  |    |
| `k+16` |    |     | d   |     | d1 |    |    |    |

Преобразуем дерево блоков таким образом, чтобы в узлах указывалась сумарная длина области памяти.
```
block1:8 ->  block5:8
 |
 \->  block2:8 -> block3:4
       |
       \->  block:4
```

Выполняем распределение памяти для областей данных блоков.
```
i > 1
Ai = Aj + nj
  j = max(l: l < i & уровень блока l < уровень блока i)
```
Т.е. для i-ого блока рассматриваются элементы таблицы в обратном порядке и отыскивается первый блок, у которого уровень меньше чем у i.


Пример:
| N блока | Ур.блока i | Объём памяти | Адрес начала памяти блока |
|:--------|:-----------|:-------------|:--------------------------|
| 1       | 1          | 8            | `k+0`                     |
| 2       | 2          | 8            | `k+0+8 = k+8`             |
| 3       | 3          | 4            | `k+8+8 = k+16`            |
| 4       | 3          | 4            | `k+16`                    |
| 5       | 2          | 8            | `k+0+8 = k+8`             |

На следующем этапе определяются адреса памяти, для конкретных переменных.
Для этого заводим массив `Ti`, который будет хранить текущий адрес очередной переменной i-ого блока.
1. Первочанально `Ti = Ai`.
2. Рассматривается таблица идентификаторов. Для очередной переменной i-ого блока `Ti` принимается как адрес переменной и `Ti` увеличивается на длину переменной.

| Переменная | Длина | Номер блока | Адрес | T1 | T2 | T3 | T4 | T5 |
|:-----------|:------|:------------|:------|:---|:---|:---|:---|:---|
|            |       |             |       |k+0 |k+8 |k+16|k+16|k+8 |
| b          | 4     | 1           | k+0   |k+4 |    |    |    |    |
| a          | 4     | 1           | k+4   |k+8 |k+8 |    |    |    |
| a1         | 4     | 2           | k+8   |    |k+12|    |    |    |
| b1         | 4     | 2           | k+12  |    |k+16|    |    |    |
| d          | 4     | 3           | k+16  |    |    |k+20|    |    |
| d1         | 4     | 4           | k+16  |    |    |    |k+20|    |
| e          | 4     | 5           | k+8   |    |    |    |    |k+12|
| f          | 4     | 5           | k+12  |    |    |    |    |k+16|
| x-например | 10    | 3           | k+20  |    |    |k+30|    |    |

Недостатки статического распределения:
1. Нельзя использовать массивы с переменными границами, когда размер определяется при выполнении программы.
2. Невозможность использовать рекурсивных функции.
