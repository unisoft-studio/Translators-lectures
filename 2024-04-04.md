# Грамматика с ограниченный контекстом. Структура правил подстановки Флойда.

Для выделения основы в левостороннем восходящем разборе распознаватель всегда использует контекст.
Если для выделения основы требует проанализировать не более, чем `m` символов слева от неё и `n` символов справа от неё,
то говорят, что эта *грамматика с (m, n) ограниченным контекстом*.

Обозначается LR(m, n).

Грамматика с простым предшествованием = LR(1, 1)

LR(m, n) является частным случаем LR(n) грамматик.
Когда нужно проанализировать все символы слева и `n` справа.

Для каждой LR(n) существует эквивалентная LR(1).

Алгоритм разбора для LR(n) грамматики основан на переводе грамматики на язык правил подстановки Флойда.

Формат правил для LR(1) грамматик выглядит следующим образом:

| M | x1...xn | y1...ym | SP | M2 |
|:-:|:-------:|:-------:|:--:|:--:|

где
* M1 - метка правила.
* x1...xn - образец для сравнения с частью строки, находящейся в стеке. Может содержать любой символ(abV).
* y1...ym - строка, заменяющая символы стека, совпавшие с образцом. Может содержать любой символ. Если y1...ym отсутствуют, то замена не выполняется.
* SP - Семантическая подпрограмма: фиксация ошибки, выход, подпрограмма перевода части исходной программы на промежуточный язык. (Может отсутствовать).
* `*` - признак того, что в стек нужно занести очередной символ входной строки.
* M2 - метка, куда надо перейти после применения правил.

Грамматический разбор начинаем с занесения в стек первого символа строки.
Отыскиваем правило, в котором образец соответствует стеку и применяем его.
После выполняем переход на M2.
И так далее.


### Построение правил подстановок Флойда

Правила бывают двух видов:
1. S0: Строятся для S ∈ VN если верхний терминальный символ стека определяет начало строки, которое может быть свёрнуто в S.
2. S1: Строится для символа S если он находится во второй, после вершины, позиции стека.

Обозначим:
* `L0` - множество символов S ∈ VN для которых необходимо построить S0.
* `L0*` - множество символов, для которых уже построено S0
* `L1` - множество символов, для которых нужно построить S1.
* `L1*` - множество символов, для которых уже построить S1.

Для построения ноль-правил предварительно строятся `LT(U)`(самые левые терминалы в разложении U).

1. Грамматику дополняем правилом `Z -> S⊥`, где `S` - начальный символ исходной грамматики, а `Z` - начальный символ новой грамматики.
2. В `L0` заносим `Z`, остальные множества пустые.

#### Образование `S0` правил.

TODO: пофиксить номера пунктов

TODO: пофиксить таблицы

0.1. Если `L0 \ L0* = ø` => идём пункт 1.1.
0.2. Для каждого символа `H ∈ L0 \ L0*` для каждого `t ∈ LT(H)` найти множество правил `K -> tp, p ∈ V*`.
     Пусть таких правил будет n.
0.3. Если `n > 1`, то формируем правило:

     | M  | x1...xn | y1...ym | SP | * | M2 | EXTRA   |
     |:--:|:-------:|:-------:|:--:|:-:|:--:|:--------|
     | H0 | t       |         |    | * | t1 | L1 += t |

0.4 Если `n = 1`, то в зависимости от вида правила:
0.4.1 Если правило вида `k -> t`, то 

      | M  | x1...xn | y1...ym | SP | * | M2 | EXTRA   |
      |:--:|:-------:|:-------:|:--:|:-:|:--:|:--------|
      | H0 | t       | K       |    | * | k1 | L1 += k |

0.4.2 Если правило вида `k -> tbp`, где `b ∈ T`, а `p ∈V*`.

      | M  | x1...xn | y1...ym | SP | * | M2 | EXTRA   |
      |:--:|:-------:|:-------:|:--:|:-:|:--:|:--------|
      | H0 | t       |         |    | * | t1 | L1 += t |

0.4.3 Если правило вида `k -> tUp`, где `U ∈ VN`, `p ∈ V*`:

      | M  | x1...xn | y1...ym | SP | * | M2 | EXTRA   |
      |:--:|:-------:|:-------:|:--:|:-:|:--:|:--------|
      | H0 | t       |         |    | * | U0 | L0 += U |

0.5 Уничтожаем метку `H0` во всех правилах кроме первого. Добавляем правило и переходим в 0.1:

      | M  | x1...xn | y1...ym | SP | * | M2 | EXTRA     |
      |:--:|:-------:|:-------:|:--:|:-:|:--:|:----------|
      | H0 | avV     |         | err|   |    | `L0*+= H` |

#### Построение S1 правил
1.1. Если `L1 \ L1* = ø`, то конец работы.
1.2. ДЛя каждого `x ∈ L1 / L2` выделить все правила грамматики, содержащие в правых частях `x`.
1.3. Для каждого выделенного правила образовать правило подстановки Флойда в зависимости от вида правила.
1.3.1. `z -> S1`,  строим правило:

      | M  | x1...xn | y1...ym | SP | * | M2 | EXTRA      |
      |:--:|:-------:|:-------:|:--:|:-:|:--:|:-----------|
      | S1 | S⊥      | Z       |exit|   |    | `L1* += S` |

1.3.2. `U -> pX`

      | M  | x1...xn | y1...ym | SP | * | M2 | EXTRA      |
      |:--:|:-------:|:-------:|:--:|:-:|:--:|:-----------|
      | X1 | pX⩜   | UANY    |    |   | U1 | `L1 += U` |

1.3.3 `U -> pXq`

      | M  | x1...xn | y1...ym | SP | * | M2 | EXTRA      |
      |:--:|:-------:|:-------:|:--:|:-:|:--:|:-----------|
      | X1 | pXq     | U       |    | * | U1 | `L1 += U` |

1.3.4 `U -> pXHq` для каждго `t ∈ LT(H)`:

      | M  | x1...xn | y1...ym | SP | * | M2 | EXTRA      |
      |:--:|:-------:|:-------:|:--:|:-:|:--:|:-----------|
      | X1 | pXt     |         |    |   | H0 | `L0 += H`  |

1.3.5 `U -> pXtbw`, где `t,b ∈ VT`:

      | M  | x1...xn | y1...ym | SP | * | M2 | EXTRA      |
      |:--:|:-------:|:-------:|:--:|:-:|:--:|:-----------|
      | X1 | pXt     |         |    | * | t1 | `L1 += t`  |

1.3.6 `U -> pXtHq`, где `t ∈ VT`:

      | M  | x1...xn | y1...ym | SP | * | M2 | EXTRA      |
      |:--:|:-------:|:-------:|:--:|:-:|:--:|:-----------|
      | X1 | pXt     |         |    | * | H0 | `L0 += H`  |

1.4. Правила с символом `⩜` в конце образца поместить после остальных, упорядочив по убыванию длины образца.

1.5. Уничтожить метку `X1` во всех правилах кроме первого и добавить правило вида:

     | M  | x1...xn | y1...ym | SP | * | M2 | EXTRA      |
     |:--:|:-------:|:-------:|:--:|:-:|:--:|:-----------|
     | X1 | ⩜     |         | err|   |    | `L1* += X`  |
     И перейти к пункту 0.1


Пример наконец-то:
```
S -> T | S + T
T -> P | T * P
P -> ид | ( S )

=>

Z -> S⊥
S -> T | S + T
T -> P | T * P
P -> ид | ( S )
```

Строим LT(U) как L(U), но в конце удаляем нетерминалы:

| U | LT(U) |
|:-:|:-----:|
| Z | ид (  |
| S | ид (  |
| T | ид (  |
| P | ид (  |

Хочу домой

| L0 | L0* | L1 | L1* |
|:--:|:---:|:--:|:---:|
| Z  |  Z  | P  | P   |
| S  |  S  | T  | T   |
| P  |     | S  |     |
|    |     |    |     |

TODO: дописать таблицы

| M  | x1...xn | y1...ym | SP | * | M2 |
|:--:|:-------:|:-------:|:--:|:-:|:--:|
| Z0 | id    | P       |    | * | P1 |
|    | (     |         |    | * | S0 |
|    | ⩜     |         |err |   |    |
| S0 | id    | P       |    | * | P1 |
|    | (     |         |    | * | S0 |
|    | ⩜     |         |err |   |    |
| P1 | `T*P⩜`| TANY    |    |   | T1 |
|    | P⩜    | TANY    |    |   | T1 |
|    | ⩜     |         |err |   |    |
| T1 | `T*`  |         |    | * | P0 |
|    | S+T⩜  | SANY    |    |   | S1 |
|    | T⩜    | SANY    |    |   | S1 |
|    | ⩜     |         |err |   |    |

И так далее!

Теперь разберём какое-нибудь предложение по таблице, которую я решил не дописывать:
```
                    a + b * (c + d) ⊥
STATE ----------------------------------------------------
Z0 P1 T1 S1 T0 P1 T1 P0 S0 P1 T1 S1 T0 P1 T1 S1 P1 T1 S1 Z
STACK ----------------------------------------------------
a  +  +  +  b  *  *  (  c  +  +  +  d  )  )  )  ⊥  ⊥  ⊥
   P  T  S  +  P  T  *  (  P  T  S  +  P  T  S  P  T  S
            S  +  +  T  *  (  (  (  S  +  +  (  *  +
               S  S  +  T  *  *  *  (  S  S  *  T  S
                     S  +  T  T  T  *  (  (  T  +
                        S  +  +  +  T  *  *  +  S
                           S  S  S  +  T  T  S
                                    S  +  +
                                       S  S
```
