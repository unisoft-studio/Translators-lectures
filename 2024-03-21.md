# Восходящий разбор для грамматик с простым предшествованием
При восходящем разборе правила применяются для свёртки исходного предложения в начальный символ грамматики.
```
S -> T | T + S
T -> ид | ид * T

a * b + c => a * T + C
          =>   T   + C
          =>   T   + T
          =>   T   + S
          => S
```


### Грамматики с простым предшествованием
Основа - это самая левая часть строки, которую следует свернуть в нетерминал.
Между двумя соседними символами сварачиваемой строки (S[i] S[i+1]) может существовать одно из трёх отношений предшествования:
1. S[i] < S[i+1] если S[i] находится слева от основы, а S[i+1] начиная от основы.
2. S[i] > S[i+1] если S[i] - правый символ основы, а S[i+1] первый после основы.
3. S[i] = S[i+1] если оба символа в основе.

Отношения >, <, = называются отношениями предшествования.
Они несимметричные.

Пусть для каждоый пары символов существует не более одного отношения предшествования,
тогда основой всегда является самая левая цепочка символов, удовлетворяющая условию
S[i] < S[i+1] = S[i+2] = ... = S[j] > S[j+1]

Пусть U, C, D нетерминалы. x,y,z,w 

Грамматика с простым предшествованием - грамматика, в которой:
1. Для каждоый упорядоченной пары терминальных и нетерминальных символов (S[i],S[j]) существует не более одного отношения предшествования.
   S[i] = S[j] если существует `U -> x S[i] S[j] y`.
   S[i] < S[j] если существует `U -> x S[i] C y` и `C =+> S[j] x`.
   S[i] > S[j] если существует `U -> x C D y` и `C =+> z S[i]` и `D =+> S[j] w` или ...
2. Правые части правил различны.

### Вывод отношений в грамматиках с простым предшествованием
Для каждого нетерминлапостроим множествa:
1. `L(U) = {S: ∃ u =+> S x, S ∈ V, x ∈ V*}` - множество всех левых символов для U.
2. `R(S) = {S: ∃ u =+> x S, S ∈ V, x ∈ V*}` - множество правых символов для U.

`S[i] = S[j]` если `∃ U -> x S[i] S[j] y`
`S[i] < S[j]` если `∃ U -> x S[i] C y` и `S[j] ∈ L(U)`
`S[i] > S[j]` если `∃ U -> x C S[j] y` и `S[i] ∈ R(U)` или `∃ U -> x C D y` и `S[i] ∈ R(C)` и `S[j] ∈ L(D)`.

Построение множеств:
1. Для каждого правила, содержащего U в левой части в L(u) заносится левые символы правых частей правил. В R(u) заносятся правые символы.
2. Если L(U) содержит нетерминальные символы a,b,c, то в L(U) добавляется L(a), L(b), L(c). Аналогично R(U)
3. Шаг 2 повторяется, пока множества не перестнут изменяться.

Пример:
```
Z -> b M b
M -> ( L | a
L -> M a )
```
| U | L(U)  | R(U)  |
|:-:|:------|:------|
| Z | b     | b     |
| M | ( a   | L a ) |
| L | M ( a | )     |


Для получения отношений:
* `=` просматриваем правило, выбирая соседние символы
* `<` отыскиваем сочитания символ-нетерминал и тогда символ меньше, чем L от нетерминала.
* `>` отыскиваем сочитания нетерминал-символ и тогда R от нетерминала больше, чем символ. Аналогично при двух нетерминалах.

Пример:
|   | Z | M | L | b | ( | a | ) |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| Z |   |   |   |   |   |   |   |
| M |   |   |   | = |   | = |   |
| L |   |   |   | > |   | > |   |
| b |   | = |   |   | < | < |   |
| ( |   | < | = |   | < | < |   |
| a |   |   |   | > |   | > | = |
| ) |   |   |   | > |   | > |   |


### Разбор в грамматиках с простым предшествованием
Разбор ведётся с помощью стека терминальных и нетерминальных символов.
Пусть требуется проверить корректность входящей строки, состоящей из терминалов t[1], ..., t[n].
Строку дополняем ограничителями: ⊥ ... ⊥.
И будем считать, что `All S: ⊥ < S, S > ⊥`
Будем использовать стек: S[i]...S[k]

1. Левый ограничитель заносим в стек.
2. На каждом шаге алгоритма сравниваем верхний символ стека и левый символ остатка строки t[i].
   Если `S[k] ≤ t[i]`, то t[i] заносим в стек.
   Если `S[k] > t[i]`, то отыскиваем в вершине стека последовательность символов S[j-1] < S[j]=S[j+1]=...=S[k].
   Симолы S[j]... составляют основу.
   Отыскиваем правило `U -> S[j]...S[k]` и выполняется свёртка. Т.е. `S[j],...S[k]` удаляется из стека, а `U` помещается.
3. Repeat.

Строка правильня, если в исходной строке остался правый ограничитель, а в стеке ограничитель и Z, где Z - начальный символ грамматики.

Для примера проверим правильность строки `b(((aa)a)a)b`:
```
⊥ b ( ( ( a   a )     a )     a )     b ⊥
─────────────────────────────────────────
⊥ b ( ( ( a M a ) L M a ) L M a ) L M b Z
  ⊥ b ( ( ( ( M a ( ( M a ( ( M a ( b M ⊥
    ⊥ b ( ( ( ( M ( ( ( M ( b ( M b ⊥ b
      ⊥ b ( ( ( ( ( b ( ( b ⊥ b ( ⊥   ⊥
        ⊥ b b ( ( b ⊥ b ( ⊥   ⊥ b
          ⊥ ⊥ b ( ⊥   ⊥ b       ⊥
              ⊥ b       ⊥
                ⊥
```
