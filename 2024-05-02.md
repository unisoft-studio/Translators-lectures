# Динамическое распределение памяти для данных.

При динамическом распределении на этапе компиляции память распределяется только внутри блоков относительно начала области данных блока.
При этом `Ti = LS`, где `LS` - длина связующей информации блоков.

В ходе выполнения программы при входе в блок выделяется память для области данных блоков.
Будем рассматривать динамическое распределение для программ, содержащих как обычные блоки, так и процедуры, вложенные в друг-друга.

Пример для проги на чём-то типо C:
```
void main()
{
    int a0, 0;
    void c() { int a1, b1, ...; }
    p1: { int a2, b2;
        void a() { int a3;
            void b()
            { int b3, ...;
                c(); ..; goto m1;}
            b2();
        }
        p2: { int a4;
                p3 { int a5; a(); ... }
            }
        m1:
        p4: { int a6, ...; }
    }
}
```

Строим дерево
```
           main(a0, b0) -> c(a1, b1)
            |
 p4(a6) <- p1(a2, b2) -> a(a3) -> b(b3)
            |
           p2(a4) -> p3(a5)
```

Дерево блоков определяет *статическую цепочку вложенности*.
Последовательность вызова блоков определяет динамическую цепочку вызовов.
```
main -> p1 -> p2 -> p3 -> a -> b -> c -x-> b
                                 -8> p1
           -9> p4 -10> p1
           -11> main
```
TODO: graph using mermaid

При динамическом распределении адрес любой переменной определяется как сумма базового адреса области начала данных блока и смещения переменной.

Для хранения базовых адресов будем использовать массив `УНБ[i]` содержащий адрес области блока i-ого уровня.

`[V]` - адрес области блока `V`

Средство реализации динамического распределения является стек.
Обозначим:
* `УС` - указатель стека.
* `к` - номер блока.
* `УБk` - уровень блока `k`
* `УБТ` - уровень текущего блока.
* `nk` - размер области данных блока `k`.
* `УНБОk` - указатель начала области данных блока, в котором описан блок `k`.
* `УНБВk` - указтель начала области данных, откуда вызван блок `k`.
* `УБВk` - уровень блока, из которого вызван блок `k`.

Связующей информацией блока `k` называется тройка:
1. `УНБОk`
2. `УНБВk`
3. `УНВk`

Связующая информация помещается в начало области данных каждого блока для `main` связующая информация - (0,0,0).

```
main (0,0,0) <- УС       УБТ = УБk = 1  УРБ[УБk] = УРБ[1] = main
       a0
       b0
    -----------
p1  ([m],[m],1)       УНБ[2] = [p1]   УБТ = 2
       a2
       b2
    -----------
p2  ([p1], [p1], 2)    УНБ[3]=[p2]   УБТ = 3
        a4
    ----------
p3  ([p2], [p2], 3)    УНБ[4] = [p3]   УБТ = 4
    ----------- <- УС новый
a   ([p1], [p3], 4)    УНБ[3] = [a]    УБТ = 3
           a3
    -----------
b   ([a], [a], 3)      УНБ[4] = [b]    УБТ = 4
          b3
    ------------
c   ([m], [b], 4)      УНБ[2] = [c]    УБТ = 2
      a1, b1
```
При входе в любой блок `k` выполняется подпрограмма "ВХОД", которая из себя представляет это: в стек заносится связующая ифномрация: 
```
СТЕК[УС] = (УНБО[УБk - 1], УНБ[УБ], УБГ)
УБТ = УБk
УНБ[УБk] = УС
УС = УС + LS + nk
```

Первый элемент связующей информацииопределяет цепочку областей данных блоков в соответствии со статической цепочкой вложенности. Второй параметор определяет динамическую цепочку вызовов блоков.

При выходе из процендуры нужно восстанавливать указатель стека (УС) и уровень текущего блока (УБТ), массив УНБ:
1. `УС = УНБ[УБТ]`
2. Извлекается связущая информация, содержащаяся по адресу укзателястека.
3. Восстанавливается `УБТ` и он равен `УБВk`
4. `УНБ[УБТ] = УНБВк`
5. По статической цепочке в цикле восстанавливаются `УНБ[УБТ-1]...УНБ[2]`

```
main (0,0,0) <- УС       УБТ = УБk = 1  УРБ[УБk] = УРБ[1] = main
       a0
       b0
    -----------
p1  ([m],[m],1)       УНБ[2] = [p1]   УБТ = 2
       a2
       b2
    -----------
p2  ([p1], [p1], 2)    УНБ[3]=[p2]   УБТ = 3
        a4
    ----------
p3  ([p2], [p2], 3)    УНБ[4] = [p3]   УБТ = 4
    ----------- <- УС новый
a   ([p1], [p3], 4)    УНБ[3] = [a]    УБТ = 3
           a3
    -----------
b   ([a], [a], 3)      УНБ[4] = [b]    УБТ = 4
          b3
```

При выходе из блока с помощью оператора перехода на метку, содержащуюся в блоке `k` выполняется выход по метке.
1. `УБТ = УБk`
2. `УС = УНБ[УБТ] + nк + LS`

```
main (0,0,0) <- УС       УБТ = УБk = 1  УРБ[УБk] = УРБ[1] = main
       a0
       b0
    -----------
p1  ([m],[m],1)       УНБ[2] = [p1]   УБТ = 2
       a2
       b2
```
Теперь у нас вход в `p4`
```
main (0,0,0)             УБТ = УБk = 1  УРБ[УБk] = УРБ[1] = main
       a0
       b0
    -----------
p1  ([m],[m],1)       УНБ[2] = [p1]   УБТ = 2
       a2
       b2
    ----------
p4  ([p1], [p1], 2)    ...[p4]   3
       a6
    ---------- <- УС
```
Выход в ...
```
main (0,0,0)             УБТ = УБk = 1  УРБ[УБk] = УРБ[1] = main
       a0
       b0
    -----------
p1  ([m],[m],1)       УНБ[2] = [p1]   УБТ = 2
       a2
       b2
    ----------
                   УБТ = 2
                   УНБ[2] = [p1]
```
Выход из `p1`
```
main (0,0,0)             УБТ = УБk = 1  УРБ[УБk] = УРБ[1] = main
       a0
       b0
    ----------- <- УС
                   УБТ = 1
                   УНБ[1] = [main]
```

Выход из `main` - это последний выход.
При последнем выходе выполняется подпрограмма "ВЫХОД ИЗ БЛОКа"
1. `УС = УНБ[УБТ]`
2. `УБТ -= 1`

```
--------------- <- УС
```
